やあ諸君。C言語五目並べバトルへようこそ。
早速今回の五目並べのルールとマスタープログラムの挙動を一通り説明する。

ルール説明の前に、今回の対戦では複数のCファイルのリンクコンパイルを行う。
一通りここで説明するが、もしパニックな場合は友達に聞くかググるか死ぬかするように。

・リンクコンパイルについて
    これは、複数のCファイルをコンパイルする方法で、とくに一つのCファイルをコンパイルするときと手順は変わらない。
    例えば、以下3つの.cファイルがあるとする。

    ・test.c
        関数 example() が記述されている。
    ・hoge.c
        関数 noname() が記述されている。
    ・main.c
        メイン関数が記述されている。メイン関数では、test.cに記述されている関数 example() と、
        hoge.cに記述されている関数　noname() を呼び出して使用している。
    
    上記3ファイルは同一ディレクトリに存在しているが、main関数がその他のファイルに存在する関数を呼び出している以外に依存関係はない。
    この場合、通常通り1ファイルずつコンパイルしても当然main.cファイルに存在しない関数(example()とnoname())を使用しているため、コンパイルエラーとなる。
    そこで、リンクコンパイルを下記で行う。
    
    gcc -o test main.c test.c hoge.c

    と同時にコンパイルしてやることで、3ファイルが同一ファイルとしてコンパイルが通り、上記の例では test という実行可能ファイルが生成される。


それでは、ルール説明に入ろう。
    ・通常の五目並べと変わらないが、番目は10×10のミニチュアサイズである。
    ・先攻は「O」後攻は「X」空欄は「-」で表示されている。
    ・初期状態は、真ん中４マスにお互いの駒が交互に置かれた状態からスタート。
    ・同じところに置いた場合はその旨の警告が出て、もう一度置き直しとなる。特にペナルティははい。
    ・5こ並べたら勝ち。勝敗がつかずに全マスが埋まった場合は、引き分け。デスマッチのない平和な世界。
    ・以下実際のゲーム盤面出力。初期状態ね。参考に。

 ###  # 1  # 2  # 3  # 4  # 5  # 6  # 7  # 8  # 9  #10  ###
 # 1   -    -    -    -    -    -    -    -    -    -   # 1
 # 2   -    -    -    -    -    -    -    -    -    -   # 2
 # 3   -    -    -    -    -    -    -    -    -    -   # 3
 # 4   -    -    -    -    -    -    -    -    -    -   # 4
 # 5   -    -    -    -    O    X    -    -    -    -   # 5
 # 6   -    -    -    -    X    O    -    -    -    -   # 6
 # 7   -    -    -    -    -    -    -    -    -    -   # 7
 # 8   -    -    -    -    -    -    -    -    -    -   # 8
 # 9   -    -    -    -    -    -    -    -    -    -   # 9
 #10   -    -    -    -    -    -    -    -    -    -   #10
 ###  # 1  # 2  # 3  # 4  # 5  # 6  # 7  # 8  # 9  #10  ###

次に、用意されているものの内容である。
・同梱内容
    ・master.c
        →マスタープログラム。バトルの時も同様のものを使用する。ソースコードの見えるようにしてあるので、
        各自対戦プログラムの作成するときに参考にするなり、これで勉強するなりしてくれ。
        こいつはマスタープログラムで、要はゲームを取り締まっている。
        プレイヤーの順番の管理から勝敗の判定やら反則やらを管理している。

    ・player1.o player2.o
        →今回諸君に作成してもらう対戦プログラムの、動作チェック用のリロケータブルファイル。
        oファイルはあまり馴染みがないかもしれないけど、こいつらも所詮.cファイルをコンパイルしてできたにすぎない。
        ただし実行ファイル(.exeとか)とはちがって、こいつ単体で実行できるわけではない。
        .cファイル同様に、

        gcc -o test player2.o

        てなかんじでコンパイルかけてやれば、実行ファイルになって使えるようになる。的な。(今回上記コンパイルしても動くものは出てこない)
        まあ、イメージとしては中身の見れない.cファイルだと思ってくれればいい。
        因みにこのファイルには俺が作った対戦用プログラムがコンパイルされてて(１も２もどっちも一緒の内容)、諸君にplayer.c player2.c を作成してもらった後に、
        
        gcc -o test player1.c player2.o

        てな塩梅でかたっぽに.oファイルをいれてコンパイルすれば、俺の対戦プログラムと対戦できるようになってる。
        動作確認ついでに、腕試ししといてくれ。

    ・player1rand.c player2rand.c
        →これはcファイルな。中身見れるからな。
        ここまで読んでるとなんとなく実装すべきものがわかってきてると思うけど、この二つのファイルはその一例。
        空いてる所にランダムに駒を置く対戦プログラムな。これでなんとなくイメージはつかめると思う。二つとも内容は一緒。
    
よし。ここまでよく頑張って読んだな。ここからは作るべきプログラムの内容を説明するぞ。
まず、player1rand.c ファイルの中身を見てみよう。

void player1(int ground[12][12], int *strategy_x, int *strategy_y)

これが諸君の作るべき対戦プログラムの中のトップ呼び出し関数。

    関数名：player1(int[12][12], *int, *int) or player2(int[12][12], *int, *int)
            ファイル名は好きにつけていいけど、関数名はこれを守ってね。

    第一引数：これは盤面の情報。毎ターン新しい現在の盤面情報が与えられるぞ。12×12の二重配列だけど、一番外回り一周は枠として使用していて、フィールドではないから、
            実質把握すべきなのは0−11の配列番号のうちの、1−10だけってことになる。引数に撮るときは12×12のサイズでとってくれよな！
            因みに、わかってるとは思うけど、
            ground[y座標][x座標]
            の関係になってるからな。パニクんなよ。
            player1が先攻、player2が後攻でプレイしたとすると、
            player1は「O」player2は「X」で表示されるわけだが、これは実際のワールドの二重配列内では、整数処理されていて、
            player1の駒は「１」player2の駒は「２」空きマスは「０」それ以外のフィールド外は「−１」で表示されている。
            
    第二引数：ポインタな。自分がそのターンに置く駒のx座標な。こいつを直接書き換えてやることで、マスタープログラムの中の実体も書き換えられるってわけ。

    第三引数：自分がそのターンに置く駒のy座標な。

    戻り値：なし

それから、player1とplayer2で二つ作ってもらうことになるんだけど、これは先行後攻の入れ替えを行うからであって、戦略を二つ考えてこいって分けじゃないからね。
中身は全く同じでOK。(先攻、後攻で確かに先攻有利なゲームだから、勝つために先攻と後攻の戦略を少し変えたければ、変えてもよし。但し今回はオセロのスタートみたく、
真ん中４ますをお互いの駒で交互に二つずつ埋めた状態から始めるから、あまり先攻後攻に有利不利はないかもね。)

ここからは作成時のコーディングルールを説明するよ。
    ・フィールド変数(関数の外側で使う変数)には、各自の名前を接頭辞としてめいじすること。
    例えば、
    int gamecount
    をフィールドで宣言したかったら、上記ではNG
    int Matsumoto_gamecount
    こうしてくれ！。少々冗長になるけど、コンフリクトを避けるためには止むを得ないのだ、、、。
    ・もし、乱数を扱うなら、もうわかってるとは思うが、rand関数とsrand関数を使うと思うんだが、
    srand関数に関してはmaster側ですでに乱数シードを初期化しているから、自分のプログラムで使うときはいきなり
    rand関数使っても乱数得られるからな。むしろsrandを自分とこで使うとバグるからな。やめとけよ。

最後に、master.cファイルの18行目に、

//#define DEBUG

ってコメントアウトがあると思う。これは、コメントアウトしたまま対戦プログラムと一緒にリンクコンパイルすると、

>$ ./test
 ###  # 1  # 2  # 3  # 4  # 5  # 6  # 7  # 8  # 9  #10  ###
 # 1   -    -    -    -    -    -    -    -    -    -   # 1
 # 2   -    -    -    -    -    -    O    -    X    -   # 2
 # 3   -    -    -    -    -    -    -    X    -    -   # 3
 # 4   -    -    -    -    -    -    X    O    -    -   # 4
 # 5   -    -    -    -    O    X    -    -    -    -   # 5
 # 6   -    -    -    -    X    O    -    -    -    -   # 6
 # 7   -    -    -    -    -    -    -    -    -    -   # 7
 # 8   -    -    -    -    -    -    -    -    -    -   # 8
 # 9   -    -    -    -    -    -    O    -    -    -   # 9
 #10   -    -    -    -    -    -    -    -    -    -   #10
 ###  # 1  # 2  # 3  # 4  # 5  # 6  # 7  # 8  # 9  #10  ###
player2(X) WIN

といううふうに最終結果だけが一回返ってきて終了するんだけど、コメントアウトをとるとDEBUGモードになって、
一手一手の対戦状況が全部コマンドラインに表示されるようになる。実装中はこれが必要になると思うから、駆使するように。

だいたいこんなもんだ！！
もし不明な点があればいつでも聞いてくれ。まずは同梱してある俺の対戦プログラムに勝ってみろ！！！
あとは、無限ループとセグフォに気をつけて、自由に楽しくコーディングするんだ！

因みに今回のゲームのプログラムは全部俺の完全オリジナルで、著作権は俺にあるが、
これを受け取った諸君はこのプログラムを自由に配布、改変してもよいものとする。

健闘を祈る。

松本 大知

